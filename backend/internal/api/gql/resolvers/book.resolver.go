package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"encoding/hex"
	"errors"
	"fmt"

	"github.com/Shelffy/shelffy/internal/api/gql/gqlmodel"
	contextvalues "github.com/Shelffy/shelffy/internal/context_values"
	"github.com/Shelffy/shelffy/internal/entities"
)

// UploadBook is the resolver for the uploadBook field.
func (r *mutationResolver) UploadBook(ctx context.Context, input *gqlmodel.UploadBookInput) (*gqlmodel.BookPayload, error) {
	user := contextvalues.GetUserOrPanic(ctx)
	uploadedBook, err := r.BooksService.Upload(
		ctx,
		entities.Book{
			Title:      input.File.Filename,
			UploadedBy: user.ID,
		},
		input.File.Size,
		input.File.File,
	)
	if err != nil {
		return nil, err
	}
	return &gqlmodel.BookPayload{
		ID:         uploadedBook.ID,
		Title:      uploadedBook.Title,
		Hash:       hex.EncodeToString(uploadedBook.Hash[:]),
		UploadedAt: uploadedBook.UploadedAt,
		UploadedBy: uploadedBook.UploadedBy,
	}, nil
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, input *gqlmodel.BookInput) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteBook - deleteBook"))
}

// Book is the resolver for the book field.
func (r *queryResolver) Book(ctx context.Context, input *gqlmodel.BookInput) (*gqlmodel.BookPayload, error) {
	book, err := r.BooksService.GetByID(ctx, input.ID)
	if err != nil {
		return nil, err
	}
	if !IsBookOwnerOrAdmin(ctx, book) {
		return nil, errors.New("access denied")
	}
	bookURL, err := BuildBookContentURL(contextvalues.GetBaseURL(ctx), book.ID)
	if err != nil {
		r.Logger.Error("error while building book url", "error", err.Error())
		return nil, errors.New("internal error")
	}
	return &gqlmodel.BookPayload{
		ID:         book.ID,
		Title:      book.Title,
		Hash:       hex.EncodeToString(book.Hash[:]),
		UploadedAt: book.UploadedAt,
		UploadedBy: book.UploadedBy,
		URL:        bookURL,
	}, nil
}

// UserBooks is the resolver for the userBooks field.
func (r *queryResolver) UserBooks(ctx context.Context, limit *uint64, offset *uint64) ([]gqlmodel.BookPayload, error) {
	user := contextvalues.GetUserOrPanic(ctx)
	dbBooks, err := r.BooksService.GetManyByUserID(ctx, user.ID, limit, offset)
	if err != nil {
		return nil, err
	}
	books := make([]gqlmodel.BookPayload, len(dbBooks))
	for i, book := range dbBooks {
		bookURL, err := BuildBookContentURL(contextvalues.GetBaseURL(ctx), book.ID)
		if err != nil {
			r.Logger.Error("error while building book url", "error", err.Error())
			return nil, errors.New("internal error")
		}
		books[i] = gqlmodel.BookPayload{
			ID:         book.ID,
			Title:      book.Title,
			Hash:       hex.EncodeToString(book.Hash[:]),
			UploadedAt: book.UploadedAt,
			UploadedBy: book.UploadedBy,
			URL:        bookURL,
		}
	}
	return books, nil
}

// UserBookTitle is the resolver for the userBookTitle field.
func (r *queryResolver) UserBookTitle(ctx context.Context, input *gqlmodel.UserBookTitleInput) (*gqlmodel.BookPayload, error) {
	panic(fmt.Errorf("not implemented: UserBookTitle - userBookTitle"))
}
